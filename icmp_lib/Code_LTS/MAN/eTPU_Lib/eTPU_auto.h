// This file is auto-generated by the ASH WARE ETEC Linker.
// It contains useful information for host-CPU side driver code

#ifndef __AUTO_eTPU_auto_H__
#define __AUTO_eTPU_auto_H__

// Register ECR, field ETB, byte address, Each Engine
// ECR.ETB = (_ENTRY_TABLE_BASE_ADDR_)>>10;
#define _ENTRY_TABLE_BASE_ADDR_                  0x00

// Starting DATA RAM address where the block copy of initialized data begins
// memcpy( ETPU_DATA_RAM_START+_GLOBAL_INIT_DATA_ADDR_, &_global_mem_init[0], _GLOBAL_DATA_SIZE_);
#define _GLOBAL_INIT_DATA_ADDR_                  0x4000

// Register MISCCMPR - ETPU MISC Compare Register
// MISCCMPR = _MISC_VALUE_;
#define _MISC_VALUE_                             0x877F3B9B

// SCM Off Opcode - opcode returned when in the weeds
// SCMOFFDATAR = _SCM_OFF_OPCODE_;
#define _SCM_OFF_OPCODE_                         0x00

// exported autodef macros from user "#pragma export_autodef_macro" commands
// none specified

// exported autodef text from user "#pragma export_autodef_text" commands
// none specified

// Global Variable/Data Size (not including scratchpad)
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_
#define _GLOBAL_VAR_SIZE_                        0x00

// Global Scratchpad Data Size in bytes
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_ + _GLOBAL_SCRATCHPAD_SIZE_
#define _GLOBAL_SCRATCHPAD_SIZE_                 0x00

// Total Global Data Size (starts at address 0, includes any global scratchpad allocation)
// address (end) = SPRAM + _GLOBAL_DATA_SIZE_
#define _GLOBAL_DATA_SIZE_                       0x00

// User Engine Variable/Data Size (not including scratchpad)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_
#define _ENGINE_VAR_SIZE_                        0x00

// Engine Scratchpad Data Size in bytes
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_ + _ENGINE_SCRATCHPAD_SIZE_
#define _ENGINE_SCRATCHPAD_SIZE_                 0x00

// Total Engine Data Size (starts at engine address 0, includes any engine scratchpad allocation)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_DATA_SIZE_
#define _ENGINE_DATA_SIZE_                       0x00

// Amount of DATA RAM (in bytes) required for the stack
// (ideally, programs require none)
// #define CHANNEL_FRAME_START (((_GLOBAL_DATA_SIZE_ + _STACK_SIZE_) + 7) & ~7)
#define _STACK_SIZE_                             0x00

// Default channel frame base address definitions
// One for the single eTPU case, one for the dual eTPU case
#define _CHANNEL_FRAME_1ETPU_BASE_ADDR  0x0
#define _CHANNEL_FRAME_2ETPU_BASE_ADDR  0x0

#if 0
// This section gives an example of how stack bases should
// be initialized for each new channel frame (replace FUNC1, etc.
// with actual function names) in a simulator script file.  Host
// code should use the same mechanism.  The conditional initialization
// is done because a channel frame will not have a stack base allocated
// if it is not needed.
#ifdef _CPBA24_FUNC1___STACKBASE_
write_chan_data24(FUNC1_CHAN1, _CPBA24_FUNC1___STACKBASE_, _ETPU_A_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC1___STACKBASE_
#ifdef _CPBA24_FUNC2___STACKBASE_
write_chan_data24(FUNC2_CHAN1, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN2, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN3, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN4, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC2___STACKBASE_
// continue on through all channels for both eTPUs...
#endif // 0

//============================================================================
//==========     eTPU_TIMER

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_TIMER_;
#define _FUNCTION_NUM_eTPU_TIMER_                0x0D

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_TIMER_;
#define _ENTRY_TABLE_TYPE_eTPU_TIMER_            0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_TIMER_Timer_option_
#define _CPBA8_eTPU_TIMER_Timer_option_          0x00
#define _CPBA8_eTPU_TIMER_Timer_status_          0x04

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_TIMER_Time_reference_
#define _CPBA24_eTPU_TIMER_Time_reference_       0x01
#define _CPBA24_eTPU_TIMER_Time_delay_           0x05

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_TIMER_Time_reference_    T_uint24
#define _CPBA_TYPE_eTPU_TIMER_Time_delay_        T_uint24
#define _CPBA_TYPE_eTPU_TIMER_Timer_option_      T_uint8
#define _CPBA_TYPE_eTPU_TIMER_Timer_status_      T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_TIMER_;
#define _FRAME_SIZE_eTPU_TIMER_                  0x08

//============================================================================
//==========     eTPU_StepperMotorFC

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_StepperMotorFC_;
#define _FUNCTION_NUM_eTPU_StepperMotorFC_       0x16

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_StepperMotorFC_;
#define _ENTRY_TABLE_TYPE_eTPU_StepperMotorFC_   0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_StepperMotorFC_TransInd_
#define _CPBA8_eTPU_StepperMotorFC_TransInd_     0x00

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_StepperMotorFC_TransInd_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_StepperMotorFC_;
#define _FRAME_SIZE_eTPU_StepperMotorFC_         0x08

//============================================================================
//==========     eTPU_StepperMotor2PH

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_StepperMotor2PH_;
#define _FUNCTION_NUM_eTPU_StepperMotor2PH_      0x0F

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_StepperMotor2PH_;
#define _ENTRY_TABLE_TYPE_eTPU_StepperMotor2PH_  0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_StepperMotor2PH_PH1_CHAN_i_
#define _CPBA8_eTPU_StepperMotor2PH_PH1_CHAN_i_  0x00
#define _CPBA8_eTPU_StepperMotor2PH_PH2_CHAN_i_  0x04
#define _CPBA8_eTPU_StepperMotor2PH_DIRECTION_i_ 0x08
#define _CPBA8_eTPU_StepperMotor2PH_F_time_base_i_ 0x0C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_StepperMotor2PH_STEP_CNT_i_
#define _CPBA24_eTPU_StepperMotor2PH_STEP_CNT_i_ 0x01
#define _CPBA24_eTPU_StepperMotor2PH_STEP_TIME_i_ 0x05
#define _CPBA24_eTPU_StepperMotor2PH_Step_State_ 0x09
#define _CPBA24_eTPU_StepperMotor2PH_T_reference_ 0x0D

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_StepperMotor2PH_PH1_CHAN_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor2PH_STEP_CNT_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor2PH_PH2_CHAN_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor2PH_STEP_TIME_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor2PH_DIRECTION_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor2PH_Step_State_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor2PH_F_time_base_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor2PH_T_reference_ T_uint24

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_StepperMotor2PH_;
#define _FRAME_SIZE_eTPU_StepperMotor2PH_        0x10

//============================================================================
//==========     eTPU_StepperMotor3PH

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_StepperMotor3PH_;
#define _FUNCTION_NUM_eTPU_StepperMotor3PH_      0x15

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_StepperMotor3PH_;
#define _ENTRY_TABLE_TYPE_eTPU_StepperMotor3PH_  0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_StepperMotor3PH_PH1_CHAN_i_
#define _CPBA8_eTPU_StepperMotor3PH_PH1_CHAN_i_  0x00
#define _CPBA8_eTPU_StepperMotor3PH_PH2_CHAN_i_  0x04
#define _CPBA8_eTPU_StepperMotor3PH_PH3_CHAN_i_  0x08
#define _CPBA8_eTPU_StepperMotor3PH_FC_PH1_i_    0x0C
#define _CPBA8_eTPU_StepperMotor3PH_FC_PH2_i_    0x10
#define _CPBA8_eTPU_StepperMotor3PH_FC_PH3_i_    0x14
#define _CPBA8_eTPU_StepperMotor3PH_GoReq_       0x18
#define _CPBA8_eTPU_StepperMotor3PH_HoldModeReq_ 0x19
#define _CPBA8_eTPU_StepperMotor3PH_HoldModeAct_ 0x1A
#define _CPBA8_eTPU_StepperMotor3PH_Step_State_  0x1B
#define _CPBA8_eTPU_StepperMotor3PH_PWM_State_   0x1C
#define _CPBA8_eTPU_StepperMotor3PH_PWM_Chan_    0x1D

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_StepperMotor3PH_POS_CMD_i_
#define _CPBA24_eTPU_StepperMotor3PH_POS_CMD_i_  0x01
#define _CPBA24_eTPU_StepperMotor3PH_STEP_CNT_i_ 0x05
#define _CPBA24_eTPU_StepperMotor3PH_STEP_TIME_i_ 0x09
#define _CPBA24_eTPU_StepperMotor3PH_OVERLAP_TIME_i_ 0x0D
#define _CPBA24_eTPU_StepperMotor3PH_PWM_OFF_TIME_i_ 0x11
#define _CPBA24_eTPU_StepperMotor3PH_PWM_ON_TIME_i_ 0x15

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PH1_CHAN_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_POS_CMD_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PH2_CHAN_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_STEP_CNT_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PH3_CHAN_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_STEP_TIME_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_FC_PH1_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_FC_PH2_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_FC_PH3_i_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_OVERLAP_TIME_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PWM_OFF_TIME_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PWM_ON_TIME_i_ T_uint24
#define _CPBA_TYPE_eTPU_StepperMotor3PH_GoReq_   T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_HoldModeReq_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_HoldModeAct_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_Step_State_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PWM_State_ T_uint8
#define _CPBA_TYPE_eTPU_StepperMotor3PH_PWM_Chan_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_StepperMotor3PH_;
#define _FRAME_SIZE_eTPU_StepperMotor3PH_        0x20

//============================================================================
//==========     eTPU_SPWM_Slave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_SPWM_Slave_;
#define _FUNCTION_NUM_eTPU_SPWM_Slave_           0x0A

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_SPWM_Slave_;
#define _ENTRY_TABLE_TYPE_eTPU_SPWM_Slave_       0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_SPWM_Slave_SPWM_slave_status_
#define _CPBA8_eTPU_SPWM_Slave_SPWM_slave_status_ 0x00
#define _CPBA8_eTPU_SPWM_Slave_F_time_base_      0x04

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_SPWM_Slave_T_period_
#define _CPBA24_eTPU_SPWM_Slave_T_period_        0x01
#define _CPBA24_eTPU_SPWM_Slave_T_pulse_on_      0x05
#define _CPBA24_eTPU_SPWM_Slave_T_offset_        0x09
#define _CPBA24_eTPU_SPWM_Slave_T_reference_PTR_ 0x0D

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_SPWM_Slave_T_period_     T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Slave_T_pulse_on_   T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Slave_T_offset_     T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Slave_SPWM_slave_status_ T_uint8
#define _CPBA_TYPE_eTPU_SPWM_Slave_T_reference_PTR_ T_ptr
#define _CPBA_TYPE_eTPU_SPWM_Slave_F_time_base_  T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_SPWM_Slave_;
#define _FRAME_SIZE_eTPU_SPWM_Slave_             0x10

//============================================================================
//==========     eTPU_SPWM_Master

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_SPWM_Master_;
#define _FUNCTION_NUM_eTPU_SPWM_Master_          0x09

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_SPWM_Master_;
#define _ENTRY_TABLE_TYPE_eTPU_SPWM_Master_      0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_SPWM_Master_F_time_base_
#define _CPBA8_eTPU_SPWM_Master_F_time_base_     0x04
#define _CPBA8_eTPU_SPWM_Master_SPWM_master_status_ 0x0C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_SPWM_Master_T_period_
#define _CPBA24_eTPU_SPWM_Master_T_period_       0x05
#define _CPBA24_eTPU_SPWM_Master_T_pulse_on_     0x0D
#define _CPBA24_eTPU_SPWM_Master_T_reference_    0x11

// tag type info used by channel frame variables

// defines for type union (typedef T_SYNC_CHANNEL_SET)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_SYNC_CHANNEL_SET_
#define _CHAN_TAG_TYPE_SIZE_T_SYNC_CHANNEL_SET_  0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_SYNC_CHANNEL_SET_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_SYNC_CHANNEL_SET_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_SYNC_CHANNEL_SET_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_SYNC_CHANNEL_SET_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_channels_ T_uint32
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_channels_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_channels_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_TAB_channel_ T_array
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_TAB_channel_ 0x00
#define _CHAN_MEMBER_TYPE_ARRAY_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_TAB_channel_ T_uint8
#define _CHAN_MEMBER_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_TAB_channel_DIM_1_LENGTH_ 0x03
#define _CHAN_MEMBER_eTPU_SPWM_Master_T_SYNC_CHANNEL_SET_TAB_channel_DIM_1_STRIDE_ 0x01

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_SPWM_Master_sync_channels_set1_
#define _CPBA_UNION_eTPU_SPWM_Master_sync_channels_set1_ 0x00
#define _CPBA_TYPE_UNION_eTPU_SPWM_Master_sync_channels_set1_ T_SYNC_CHANNEL_SET
#define _CPBA_UNION_eTPU_SPWM_Master_sync_channels_set2_ 0x08
#define _CPBA_TYPE_UNION_eTPU_SPWM_Master_sync_channels_set2_ T_SYNC_CHANNEL_SET

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_SPWM_Master_sync_channels_set1_ T_union
#define _CPBA_TYPE_eTPU_SPWM_Master_T_period_    T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Master_sync_channels_set2_ T_union
#define _CPBA_TYPE_eTPU_SPWM_Master_T_pulse_on_  T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Master_T_reference_ T_uint24
#define _CPBA_TYPE_eTPU_SPWM_Master_F_time_base_ T_uint8
#define _CPBA_TYPE_eTPU_SPWM_Master_SPWM_master_status_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_SPWM_Master_;
#define _FRAME_SIZE_eTPU_SPWM_Master_            0x18

//============================================================================
//==========     eTPU_QOM

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_QOM_;
#define _FUNCTION_NUM_eTPU_QOM_                  0x0B

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_QOM_;
#define _ENTRY_TABLE_TYPE_eTPU_QOM_              0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_QOM_qom_option_
#define _CPBA8_eTPU_QOM_qom_option_              0x00

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_QOM_PTR_event_table_end_
#define _CPBA24_eTPU_QOM_PTR_event_table_end_    0x01
#define _CPBA24_eTPU_QOM_PTR_event_table_current_ 0x05
#define _CPBA24_eTPU_QOM_nb_loop_                0x09
#define _CPBA24_eTPU_QOM_PTR_T_reference_        0x0D
#define _CPBA24_eTPU_QOM_T_reference_            0x11

// tag type info used by channel frame variables

// defines for type struct (typedef T_QOM_EVENT)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_QOM_EVENT_
#define _CHAN_TAG_TYPE_SIZE_T_QOM_EVENT_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_QOM_EVENT_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_QOM_EVENT_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_QOM_EVENT_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_QOM_EVENT_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_QOM_T_QOM_EVENT_T_offset_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_QOM_T_QOM_EVENT_T_offset_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_QOM_T_QOM_EVENT_T_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_QOM_T_QOM_EVENT_pin_state_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_QOM_T_QOM_EVENT_pin_state_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_STRUCT_eTPU_QOM_first_table_event_
#define _CPBA_STRUCT_eTPU_QOM_first_table_event_ 0x14
#define _CPBA_TYPE_STRUCT_eTPU_QOM_first_table_event_ T_QOM_EVENT

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_QOM_PTR_event_table_end_ T_ptr
#define _CPBA_TYPE_eTPU_QOM_PTR_event_table_current_ T_ptr
#define _CPBA_TYPE_eTPU_QOM_nb_loop_             T_uint24
#define _CPBA_TYPE_eTPU_QOM_PTR_T_reference_     T_ptr
#define _CPBA_TYPE_eTPU_QOM_T_reference_         T_uint24
#define _CPBA_TYPE_eTPU_QOM_qom_option_          T_uint8
#define _CPBA_TYPE_eTPU_QOM_first_table_event_   T_struct

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_QOM_;
#define _FRAME_SIZE_eTPU_QOM_                    0x18

//============================================================================
//==========     eTPU_QD

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_QD_;
#define _FUNCTION_NUM_eTPU_QD_                   0x17

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_QD_;
#define _ENTRY_TABLE_TYPE_eTPU_QD_               0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_QD_direction_
#define _CPBA8_eTPU_QD_direction_                0x00
#define _CPBA8_eTPU_QD_last_direction_           0x04
#define _CPBA8_eTPU_QD_pins_                     0x08
#define _CPBA8_eTPU_QD_mode_current_             0x0C
#define _CPBA8_eTPU_QD_options_                  0x10

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_QD_pc_
#define _CPBA24_eTPU_QD_pc_                      0x01
#define _CPBA24_eTPU_QD_rc_                      0x05
#define _CPBA24_eTPU_QD_period_                  0x09
#define _CPBA24_eTPU_QD_pc_max_                  0x0D
#define _CPBA24_eTPU_QD_pc_interrupt1_           0x11
#define _CPBA24_eTPU_QD_pc_interrupt2_           0x15
#define _CPBA24_eTPU_QD_slow_normal_threshold_   0x19
#define _CPBA24_eTPU_QD_normal_slow_threshold_   0x1D
#define _CPBA24_eTPU_QD_normal_fast_threshold_   0x21
#define _CPBA24_eTPU_QD_fast_normal_threshold_   0x25
#define _CPBA24_eTPU_QD_last_leading_edge_       0x29
#define _CPBA24_eTPU_QD_last_edge_               0x2D
#define _CPBA24_eTPU_QD_pc_sc_                   0x31
#define _CPBA24_eTPU_QD_ratio1_                  0x35
#define _CPBA24_eTPU_QD_ratio2_                  0x39

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_QD_pc_                   T_sint24
#define _CPBA_TYPE_eTPU_QD_rc_                   T_sint24
#define _CPBA_TYPE_eTPU_QD_period_               T_sint24
#define _CPBA_TYPE_eTPU_QD_pc_max_               T_uint24
#define _CPBA_TYPE_eTPU_QD_pc_interrupt1_        T_uint24
#define _CPBA_TYPE_eTPU_QD_pc_interrupt2_        T_uint24
#define _CPBA_TYPE_eTPU_QD_slow_normal_threshold_ T_uint24
#define _CPBA_TYPE_eTPU_QD_normal_slow_threshold_ T_uint24
#define _CPBA_TYPE_eTPU_QD_normal_fast_threshold_ T_uint24
#define _CPBA_TYPE_eTPU_QD_fast_normal_threshold_ T_uint24
#define _CPBA_TYPE_eTPU_QD_last_leading_edge_    T_sint24
#define _CPBA_TYPE_eTPU_QD_last_edge_            T_sint24
#define _CPBA_TYPE_eTPU_QD_pc_sc_                T_sint24
#define _CPBA_TYPE_eTPU_QD_direction_            T_sint8
#define _CPBA_TYPE_eTPU_QD_last_direction_       T_sint8
#define _CPBA_TYPE_eTPU_QD_pins_                 T_sint8
#define _CPBA_TYPE_eTPU_QD_mode_current_         T_sint8
#define _CPBA_TYPE_eTPU_QD_options_              T_sint8
#define _CPBA_TYPE_eTPU_QD_ratio1_               T_sfract24
#define _CPBA_TYPE_eTPU_QD_ratio2_               T_sfract24

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_QD_;
#define _FRAME_SIZE_eTPU_QD_                     0x40

//============================================================================
//==========     eTPU_Leak_TestPin

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_Leak_TestPin_;
#define _FUNCTION_NUM_eTPU_Leak_TestPin_         0x08

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_Leak_TestPin_;
#define _ENTRY_TABLE_TYPE_eTPU_Leak_TestPin_     0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_Leak_TestPin_acq_polarisation_
#define _CPBA8_eTPU_Leak_TestPin_acq_polarisation_ 0x04
#define _CPBA8_eTPU_Leak_TestPin_mux0_value_     0x0C
#define _CPBA8_eTPU_Leak_TestPin_clock_offset_   0x10
#define _CPBA8_eTPU_Leak_TestPin_convstart_offset_ 0x14
#define _CPBA8_eTPU_Leak_TestPin_channel_reference_ 0x18
#define _CPBA8_eTPU_Leak_TestPin_index_          0x3C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_Leak_TestPin_T_clock_period_
#define _CPBA24_eTPU_Leak_TestPin_T_clock_period_ 0x05
#define _CPBA24_eTPU_Leak_TestPin_T_pulse_width_ 0x0D
#define _CPBA24_eTPU_Leak_TestPin_T_setup_conv_  0x11
#define _CPBA24_eTPU_Leak_TestPin_T_init_test_   0x15
#define _CPBA24_eTPU_Leak_TestPin_T_leak_timeout_ 0x19
#define _CPBA24_eTPU_Leak_TestPin_pin_ready_mask_ 0x3D
#define _CPBA24_eTPU_Leak_TestPin_pin_ready_     0x41

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_eTPU_Leak_TestPin_TAB_mux_
#define _CPBA_ARRAY_eTPU_Leak_TestPin_TAB_mux_   0x1C
#define _CPBA_TYPE_ARRAY_eTPU_Leak_TestPin_TAB_mux_ T_union
#define _CPBA_ARRAY_eTPU_Leak_TestPin_TAB_mux_DIM_1_LENGTH_ 0x06
#define _CPBA_ARRAY_eTPU_Leak_TestPin_TAB_mux_DIM_1_STRIDE_ 0x04

// tag type info used by channel frame variables

// defines for type union (typedef T_P0_ACCESS)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_P0_ACCESS_T_setup_test_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_P0_ACCESS_T_setup_test_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_P0_ACCESS_T_setup_test_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_P0_ACCESS_leak_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_P0_ACCESS_leak_status_ 0x00
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_P2_ACCESS_T_setup_mux_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_P2_ACCESS_T_setup_mux_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_P2_ACCESS_nb_mux_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_P2_ACCESS_nb_mux_ 0x00
// defines for type union (typedef T_PIN_DEFINITION)
#define _CHAN_TAG_TYPE_SIZE_T_PIN_DEFINITION_    0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_PIN_DEFINITION_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_PIN_DEFINITION_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_PIN_DEFINITION_pin_offset_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_PIN_DEFINITION_pin_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_TestPin_T_PIN_DEFINITION_pin_value_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_TestPin_T_PIN_DEFINITION_pin_value_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_Leak_TestPin_p0_
#define _CPBA_UNION_eTPU_Leak_TestPin_p0_        0x00
#define _CPBA_TYPE_UNION_eTPU_Leak_TestPin_p0_   T_P0_ACCESS
#define _CPBA_UNION_eTPU_Leak_TestPin_p2_        0x08
#define _CPBA_TYPE_UNION_eTPU_Leak_TestPin_p2_   T_P2_ACCESS
#define _CPBA_UNION_eTPU_Leak_TestPin_test_hi_   0x34
#define _CPBA_TYPE_UNION_eTPU_Leak_TestPin_test_hi_ T_PIN_DEFINITION
#define _CPBA_UNION_eTPU_Leak_TestPin_test_lo_   0x38
#define _CPBA_TYPE_UNION_eTPU_Leak_TestPin_test_lo_ T_PIN_DEFINITION

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_Leak_TestPin_p0_         T_union
#define _CPBA_TYPE_eTPU_Leak_TestPin_T_clock_period_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_p2_         T_union
#define _CPBA_TYPE_eTPU_Leak_TestPin_T_pulse_width_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_acq_polarisation_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_TestPin_T_setup_conv_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_T_init_test_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_T_leak_timeout_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_mux0_value_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_TestPin_TAB_mux_    T_array
#define _CPBA_TYPE_eTPU_Leak_TestPin_test_hi_    T_union
#define _CPBA_TYPE_eTPU_Leak_TestPin_test_lo_    T_union
#define _CPBA_TYPE_eTPU_Leak_TestPin_clock_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_TestPin_convstart_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_TestPin_channel_reference_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_TestPin_pin_ready_mask_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_pin_ready_  T_uint24
#define _CPBA_TYPE_eTPU_Leak_TestPin_index_      T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_Leak_TestPin_;
#define _FRAME_SIZE_eTPU_Leak_TestPin_           0x48

//============================================================================
//==========     eTPU_Leak_Clock

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_Leak_Clock_;
#define _FUNCTION_NUM_eTPU_Leak_Clock_           0x07

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_Leak_Clock_;
#define _ENTRY_TABLE_TYPE_eTPU_Leak_Clock_       0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_Leak_Clock_acq_polarisation_
#define _CPBA8_eTPU_Leak_Clock_acq_polarisation_ 0x04
#define _CPBA8_eTPU_Leak_Clock_mux0_value_       0x0C
#define _CPBA8_eTPU_Leak_Clock_clock_offset_     0x10
#define _CPBA8_eTPU_Leak_Clock_convstart_offset_ 0x14
#define _CPBA8_eTPU_Leak_Clock_channel_reference_ 0x18
#define _CPBA8_eTPU_Leak_Clock_index_            0x3C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_Leak_Clock_T_clock_period_
#define _CPBA24_eTPU_Leak_Clock_T_clock_period_  0x05
#define _CPBA24_eTPU_Leak_Clock_T_pulse_width_   0x0D
#define _CPBA24_eTPU_Leak_Clock_T_setup_conv_    0x11
#define _CPBA24_eTPU_Leak_Clock_T_init_test_     0x15
#define _CPBA24_eTPU_Leak_Clock_T_leak_timeout_  0x19
#define _CPBA24_eTPU_Leak_Clock_pin_ready_mask_  0x3D
#define _CPBA24_eTPU_Leak_Clock_pin_ready_       0x41

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_eTPU_Leak_Clock_TAB_mux_
#define _CPBA_ARRAY_eTPU_Leak_Clock_TAB_mux_     0x1C
#define _CPBA_TYPE_ARRAY_eTPU_Leak_Clock_TAB_mux_ T_union
#define _CPBA_ARRAY_eTPU_Leak_Clock_TAB_mux_DIM_1_LENGTH_ 0x06
#define _CPBA_ARRAY_eTPU_Leak_Clock_TAB_mux_DIM_1_STRIDE_ 0x04

// tag type info used by channel frame variables

// defines for type union (typedef T_P0_ACCESS)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_P0_ACCESS_T_setup_test_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_P0_ACCESS_T_setup_test_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_P0_ACCESS_T_setup_test_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_P0_ACCESS_leak_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_P0_ACCESS_leak_status_ 0x00
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_P2_ACCESS_T_setup_mux_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_P2_ACCESS_T_setup_mux_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_P2_ACCESS_nb_mux_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_P2_ACCESS_nb_mux_ 0x00
// defines for type union (typedef T_PIN_DEFINITION)
#define _CHAN_TAG_TYPE_SIZE_T_PIN_DEFINITION_    0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_PIN_DEFINITION_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_PIN_DEFINITION_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_PIN_DEFINITION_pin_offset_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_PIN_DEFINITION_pin_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_Clock_T_PIN_DEFINITION_pin_value_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_Clock_T_PIN_DEFINITION_pin_value_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_Leak_Clock_p0_
#define _CPBA_UNION_eTPU_Leak_Clock_p0_          0x00
#define _CPBA_TYPE_UNION_eTPU_Leak_Clock_p0_     T_P0_ACCESS
#define _CPBA_UNION_eTPU_Leak_Clock_p2_          0x08
#define _CPBA_TYPE_UNION_eTPU_Leak_Clock_p2_     T_P2_ACCESS
#define _CPBA_UNION_eTPU_Leak_Clock_test_hi_     0x34
#define _CPBA_TYPE_UNION_eTPU_Leak_Clock_test_hi_ T_PIN_DEFINITION
#define _CPBA_UNION_eTPU_Leak_Clock_test_lo_     0x38
#define _CPBA_TYPE_UNION_eTPU_Leak_Clock_test_lo_ T_PIN_DEFINITION

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_Leak_Clock_p0_           T_union
#define _CPBA_TYPE_eTPU_Leak_Clock_T_clock_period_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_p2_           T_union
#define _CPBA_TYPE_eTPU_Leak_Clock_T_pulse_width_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_acq_polarisation_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_Clock_T_setup_conv_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_T_init_test_  T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_T_leak_timeout_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_mux0_value_   T_uint8
#define _CPBA_TYPE_eTPU_Leak_Clock_TAB_mux_      T_array
#define _CPBA_TYPE_eTPU_Leak_Clock_test_hi_      T_union
#define _CPBA_TYPE_eTPU_Leak_Clock_test_lo_      T_union
#define _CPBA_TYPE_eTPU_Leak_Clock_clock_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_Clock_convstart_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_Clock_channel_reference_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_Clock_pin_ready_mask_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_pin_ready_    T_uint24
#define _CPBA_TYPE_eTPU_Leak_Clock_index_        T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_Leak_Clock_;
#define _FRAME_SIZE_eTPU_Leak_Clock_             0x48

//============================================================================
//==========     eTPU_Leak_ConvStartPin

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_Leak_ConvStartPin_;
#define _FUNCTION_NUM_eTPU_Leak_ConvStartPin_    0x06

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_Leak_ConvStartPin_;
#define _ENTRY_TABLE_TYPE_eTPU_Leak_ConvStartPin_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_Leak_ConvStartPin_acq_polarisation_
#define _CPBA8_eTPU_Leak_ConvStartPin_acq_polarisation_ 0x04
#define _CPBA8_eTPU_Leak_ConvStartPin_mux0_value_ 0x0C
#define _CPBA8_eTPU_Leak_ConvStartPin_clock_offset_ 0x10
#define _CPBA8_eTPU_Leak_ConvStartPin_convstart_offset_ 0x14
#define _CPBA8_eTPU_Leak_ConvStartPin_channel_reference_ 0x18
#define _CPBA8_eTPU_Leak_ConvStartPin_index_     0x3C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_Leak_ConvStartPin_T_clock_period_
#define _CPBA24_eTPU_Leak_ConvStartPin_T_clock_period_ 0x05
#define _CPBA24_eTPU_Leak_ConvStartPin_T_pulse_width_ 0x0D
#define _CPBA24_eTPU_Leak_ConvStartPin_T_setup_conv_ 0x11
#define _CPBA24_eTPU_Leak_ConvStartPin_T_init_test_ 0x15
#define _CPBA24_eTPU_Leak_ConvStartPin_T_leak_timeout_ 0x19
#define _CPBA24_eTPU_Leak_ConvStartPin_pin_ready_mask_ 0x3D
#define _CPBA24_eTPU_Leak_ConvStartPin_pin_ready_ 0x41

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_eTPU_Leak_ConvStartPin_TAB_mux_
#define _CPBA_ARRAY_eTPU_Leak_ConvStartPin_TAB_mux_ 0x1C
#define _CPBA_TYPE_ARRAY_eTPU_Leak_ConvStartPin_TAB_mux_ T_union
#define _CPBA_ARRAY_eTPU_Leak_ConvStartPin_TAB_mux_DIM_1_LENGTH_ 0x06
#define _CPBA_ARRAY_eTPU_Leak_ConvStartPin_TAB_mux_DIM_1_STRIDE_ 0x04

// tag type info used by channel frame variables

// defines for type union (typedef T_P0_ACCESS)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_P0_ACCESS_T_setup_test_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_P0_ACCESS_T_setup_test_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_P0_ACCESS_T_setup_test_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_P0_ACCESS_leak_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_P0_ACCESS_leak_status_ 0x00
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_P2_ACCESS_T_setup_mux_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_P2_ACCESS_T_setup_mux_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_P2_ACCESS_nb_mux_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_P2_ACCESS_nb_mux_ 0x00
// defines for type union (typedef T_PIN_DEFINITION)
#define _CHAN_TAG_TYPE_SIZE_T_PIN_DEFINITION_    0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_PIN_DEFINITION_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_PIN_DEFINITION_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_PIN_DEFINITION_pin_offset_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_PIN_DEFINITION_pin_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ConvStartPin_T_PIN_DEFINITION_pin_value_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ConvStartPin_T_PIN_DEFINITION_pin_value_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_Leak_ConvStartPin_p0_
#define _CPBA_UNION_eTPU_Leak_ConvStartPin_p0_   0x00
#define _CPBA_TYPE_UNION_eTPU_Leak_ConvStartPin_p0_ T_P0_ACCESS
#define _CPBA_UNION_eTPU_Leak_ConvStartPin_p2_   0x08
#define _CPBA_TYPE_UNION_eTPU_Leak_ConvStartPin_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_Leak_ConvStartPin_test_hi_ 0x34
#define _CPBA_TYPE_UNION_eTPU_Leak_ConvStartPin_test_hi_ T_PIN_DEFINITION
#define _CPBA_UNION_eTPU_Leak_ConvStartPin_test_lo_ 0x38
#define _CPBA_TYPE_UNION_eTPU_Leak_ConvStartPin_test_lo_ T_PIN_DEFINITION

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_p0_    T_union
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_T_clock_period_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_p2_    T_union
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_T_pulse_width_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_acq_polarisation_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_T_setup_conv_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_T_init_test_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_T_leak_timeout_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_mux0_value_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_TAB_mux_ T_array
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_test_hi_ T_union
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_test_lo_ T_union
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_clock_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_convstart_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_channel_reference_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_pin_ready_mask_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_pin_ready_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ConvStartPin_index_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_Leak_ConvStartPin_;
#define _FRAME_SIZE_eTPU_Leak_ConvStartPin_      0x48

//============================================================================
//==========     eTPU_Leak_MuxPin

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_Leak_MuxPin_;
#define _FUNCTION_NUM_eTPU_Leak_MuxPin_          0x05

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_Leak_MuxPin_;
#define _ENTRY_TABLE_TYPE_eTPU_Leak_MuxPin_      0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_Leak_MuxPin_acq_polarisation_
#define _CPBA8_eTPU_Leak_MuxPin_acq_polarisation_ 0x04
#define _CPBA8_eTPU_Leak_MuxPin_mux0_value_      0x0C
#define _CPBA8_eTPU_Leak_MuxPin_clock_offset_    0x10
#define _CPBA8_eTPU_Leak_MuxPin_convstart_offset_ 0x14
#define _CPBA8_eTPU_Leak_MuxPin_channel_reference_ 0x18
#define _CPBA8_eTPU_Leak_MuxPin_index_           0x3C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_Leak_MuxPin_T_clock_period_
#define _CPBA24_eTPU_Leak_MuxPin_T_clock_period_ 0x05
#define _CPBA24_eTPU_Leak_MuxPin_T_pulse_width_  0x0D
#define _CPBA24_eTPU_Leak_MuxPin_T_setup_conv_   0x11
#define _CPBA24_eTPU_Leak_MuxPin_T_init_test_    0x15
#define _CPBA24_eTPU_Leak_MuxPin_T_leak_timeout_ 0x19
#define _CPBA24_eTPU_Leak_MuxPin_pin_ready_mask_ 0x3D
#define _CPBA24_eTPU_Leak_MuxPin_pin_ready_      0x41

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_eTPU_Leak_MuxPin_TAB_mux_
#define _CPBA_ARRAY_eTPU_Leak_MuxPin_TAB_mux_    0x1C
#define _CPBA_TYPE_ARRAY_eTPU_Leak_MuxPin_TAB_mux_ T_union
#define _CPBA_ARRAY_eTPU_Leak_MuxPin_TAB_mux_DIM_1_LENGTH_ 0x06
#define _CPBA_ARRAY_eTPU_Leak_MuxPin_TAB_mux_DIM_1_STRIDE_ 0x04

// tag type info used by channel frame variables

// defines for type union (typedef T_P0_ACCESS)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_P0_ACCESS_T_setup_test_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_P0_ACCESS_T_setup_test_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_P0_ACCESS_T_setup_test_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_P0_ACCESS_leak_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_P0_ACCESS_leak_status_ 0x00
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_P2_ACCESS_T_setup_mux_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_P2_ACCESS_T_setup_mux_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_P2_ACCESS_nb_mux_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_P2_ACCESS_nb_mux_ 0x00
// defines for type union (typedef T_PIN_DEFINITION)
#define _CHAN_TAG_TYPE_SIZE_T_PIN_DEFINITION_    0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_PIN_DEFINITION_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_PIN_DEFINITION_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_PIN_DEFINITION_pin_offset_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_PIN_DEFINITION_pin_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_MuxPin_T_PIN_DEFINITION_pin_value_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_MuxPin_T_PIN_DEFINITION_pin_value_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_Leak_MuxPin_p0_
#define _CPBA_UNION_eTPU_Leak_MuxPin_p0_         0x00
#define _CPBA_TYPE_UNION_eTPU_Leak_MuxPin_p0_    T_P0_ACCESS
#define _CPBA_UNION_eTPU_Leak_MuxPin_p2_         0x08
#define _CPBA_TYPE_UNION_eTPU_Leak_MuxPin_p2_    T_P2_ACCESS
#define _CPBA_UNION_eTPU_Leak_MuxPin_test_hi_    0x34
#define _CPBA_TYPE_UNION_eTPU_Leak_MuxPin_test_hi_ T_PIN_DEFINITION
#define _CPBA_UNION_eTPU_Leak_MuxPin_test_lo_    0x38
#define _CPBA_TYPE_UNION_eTPU_Leak_MuxPin_test_lo_ T_PIN_DEFINITION

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_Leak_MuxPin_p0_          T_union
#define _CPBA_TYPE_eTPU_Leak_MuxPin_T_clock_period_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_p2_          T_union
#define _CPBA_TYPE_eTPU_Leak_MuxPin_T_pulse_width_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_acq_polarisation_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_MuxPin_T_setup_conv_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_T_init_test_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_T_leak_timeout_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_mux0_value_  T_uint8
#define _CPBA_TYPE_eTPU_Leak_MuxPin_TAB_mux_     T_array
#define _CPBA_TYPE_eTPU_Leak_MuxPin_test_hi_     T_union
#define _CPBA_TYPE_eTPU_Leak_MuxPin_test_lo_     T_union
#define _CPBA_TYPE_eTPU_Leak_MuxPin_clock_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_MuxPin_convstart_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_MuxPin_channel_reference_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_MuxPin_pin_ready_mask_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_pin_ready_   T_uint24
#define _CPBA_TYPE_eTPU_Leak_MuxPin_index_       T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_Leak_MuxPin_;
#define _FRAME_SIZE_eTPU_Leak_MuxPin_            0x48

//============================================================================
//==========     eTPU_Leak_ReferencePin

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_Leak_ReferencePin_;
#define _FUNCTION_NUM_eTPU_Leak_ReferencePin_    0x04

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_Leak_ReferencePin_;
#define _ENTRY_TABLE_TYPE_eTPU_Leak_ReferencePin_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_Leak_ReferencePin_acq_polarisation_
#define _CPBA8_eTPU_Leak_ReferencePin_acq_polarisation_ 0x04
#define _CPBA8_eTPU_Leak_ReferencePin_mux0_value_ 0x0C
#define _CPBA8_eTPU_Leak_ReferencePin_clock_offset_ 0x10
#define _CPBA8_eTPU_Leak_ReferencePin_convstart_offset_ 0x14
#define _CPBA8_eTPU_Leak_ReferencePin_channel_reference_ 0x18
#define _CPBA8_eTPU_Leak_ReferencePin_index_     0x3C

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_Leak_ReferencePin_T_clock_period_
#define _CPBA24_eTPU_Leak_ReferencePin_T_clock_period_ 0x05
#define _CPBA24_eTPU_Leak_ReferencePin_T_pulse_width_ 0x0D
#define _CPBA24_eTPU_Leak_ReferencePin_T_setup_conv_ 0x11
#define _CPBA24_eTPU_Leak_ReferencePin_T_init_test_ 0x15
#define _CPBA24_eTPU_Leak_ReferencePin_T_leak_timeout_ 0x19
#define _CPBA24_eTPU_Leak_ReferencePin_pin_ready_mask_ 0x3D
#define _CPBA24_eTPU_Leak_ReferencePin_pin_ready_ 0x41

// Channel Array Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_ARRAY_eTPU_Leak_ReferencePin_TAB_mux_
#define _CPBA_ARRAY_eTPU_Leak_ReferencePin_TAB_mux_ 0x1C
#define _CPBA_TYPE_ARRAY_eTPU_Leak_ReferencePin_TAB_mux_ T_union
#define _CPBA_ARRAY_eTPU_Leak_ReferencePin_TAB_mux_DIM_1_LENGTH_ 0x06
#define _CPBA_ARRAY_eTPU_Leak_ReferencePin_TAB_mux_DIM_1_STRIDE_ 0x04

// tag type info used by channel frame variables

// defines for type union (typedef T_P0_ACCESS)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_SIZE_T_P0_ACCESS_         0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P0_ACCESS_     0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P0_ACCESS_    0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_P0_ACCESS_T_setup_test_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_P0_ACCESS_T_setup_test_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_P0_ACCESS_T_setup_test_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_P0_ACCESS_leak_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_P0_ACCESS_leak_status_ 0x00
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_P2_ACCESS_T_setup_mux_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_P2_ACCESS_T_setup_mux_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_P2_ACCESS_nb_mux_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_P2_ACCESS_nb_mux_ 0x00
// defines for type union (typedef T_PIN_DEFINITION)
#define _CHAN_TAG_TYPE_SIZE_T_PIN_DEFINITION_    0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_PIN_DEFINITION_ 0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_PIN_DEFINITION_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_PIN_DEFINITION_pin_offset_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_PIN_DEFINITION_pin_offset_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_Leak_ReferencePin_T_PIN_DEFINITION_pin_value_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_Leak_ReferencePin_T_PIN_DEFINITION_pin_value_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_Leak_ReferencePin_p0_
#define _CPBA_UNION_eTPU_Leak_ReferencePin_p0_   0x00
#define _CPBA_TYPE_UNION_eTPU_Leak_ReferencePin_p0_ T_P0_ACCESS
#define _CPBA_UNION_eTPU_Leak_ReferencePin_p2_   0x08
#define _CPBA_TYPE_UNION_eTPU_Leak_ReferencePin_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_Leak_ReferencePin_test_hi_ 0x34
#define _CPBA_TYPE_UNION_eTPU_Leak_ReferencePin_test_hi_ T_PIN_DEFINITION
#define _CPBA_UNION_eTPU_Leak_ReferencePin_test_lo_ 0x38
#define _CPBA_TYPE_UNION_eTPU_Leak_ReferencePin_test_lo_ T_PIN_DEFINITION

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_p0_    T_union
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_T_clock_period_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_p2_    T_union
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_T_pulse_width_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_acq_polarisation_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_T_setup_conv_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_T_init_test_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_T_leak_timeout_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_mux0_value_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_TAB_mux_ T_array
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_test_hi_ T_union
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_test_lo_ T_union
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_clock_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_convstart_offset_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_channel_reference_ T_uint8
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_pin_ready_mask_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_pin_ready_ T_uint24
#define _CPBA_TYPE_eTPU_Leak_ReferencePin_index_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_Leak_ReferencePin_;
#define _FRAME_SIZE_eTPU_Leak_ReferencePin_      0x48

//============================================================================
//==========     eTPU_A429_TransmitSlave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_A429_TransmitSlave_;
#define _FUNCTION_NUM_eTPU_A429_TransmitSlave_   0x03

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_A429_TransmitSlave_;
#define _ENTRY_TABLE_TYPE_eTPU_A429_TransmitSlave_ 0x01

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_A429_TransmitSlave_bit_mask_
#define _CPBA24_eTPU_A429_TransmitSlave_bit_mask_ 0x05
#define _CPBA24_eTPU_A429_TransmitSlave_PTR_buffer_current_ 0x0D
#define _CPBA24_eTPU_A429_TransmitSlave_PTR_buffer_end_ 0x11

// tag type info used by channel frame variables

// defines for type struct AW_ANONYMOUS_STRUCT_1
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_AW_ANONYMOUS_STRUCT_1_DataOut_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_AW_ANONYMOUS_STRUCT_1_DataOut_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_AW_ANONYMOUS_STRUCT_1_DataOut_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_AW_ANONYMOUS_STRUCT_1_LabelOut_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_AW_ANONYMOUS_STRUCT_1_LabelOut_ 0x00
// defines for type union (typedef T_ARINC_WORD_OUT)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_OUT_    0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_OUT_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_OUT_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_WordOut_ T_uint32
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_WordOut_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_WordOut_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_Field_ T_struct
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_Field_ 0x00
#define _CHAN_MEMBER_TYPE_STRUCT_eTPU_A429_TransmitSlave_T_ARINC_WORD_OUT_Field_ AW_ANONYMOUS_STRUCT_1
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_T_P2_ACCESS_bit_time_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_T_P2_ACCESS_bit_time_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitSlave_T_P2_ACCESS_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitSlave_T_P2_ACCESS_status_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_A429_TransmitSlave_arinc_MSG_
#define _CPBA_UNION_eTPU_A429_TransmitSlave_arinc_MSG_ 0x00
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitSlave_arinc_MSG_ T_ARINC_WORD_OUT
#define _CPBA_UNION_eTPU_A429_TransmitSlave_p2_  0x08
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitSlave_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_A429_TransmitSlave_first_data_ 0x14
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitSlave_first_data_ T_ARINC_WORD_OUT

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_arinc_MSG_ T_union
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_bit_mask_ T_sint24
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_p2_   T_union
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_PTR_buffer_current_ T_ptr
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_PTR_buffer_end_ T_ptr
#define _CPBA_TYPE_eTPU_A429_TransmitSlave_first_data_ T_union

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_A429_TransmitSlave_;
#define _FRAME_SIZE_eTPU_A429_TransmitSlave_     0x18

//============================================================================
//==========     eTPU_A429_TransmitMaster

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_A429_TransmitMaster_;
#define _FUNCTION_NUM_eTPU_A429_TransmitMaster_  0x02

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_A429_TransmitMaster_;
#define _ENTRY_TABLE_TYPE_eTPU_A429_TransmitMaster_ 0x01

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_A429_TransmitMaster_bit_mask_
#define _CPBA24_eTPU_A429_TransmitMaster_bit_mask_ 0x05
#define _CPBA24_eTPU_A429_TransmitMaster_PTR_buffer_current_ 0x0D
#define _CPBA24_eTPU_A429_TransmitMaster_PTR_buffer_end_ 0x11

// tag type info used by channel frame variables

// defines for type struct AW_ANONYMOUS_STRUCT_1
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_AW_ANONYMOUS_STRUCT_1_DataOut_ T_uint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_AW_ANONYMOUS_STRUCT_1_DataOut_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_AW_ANONYMOUS_STRUCT_1_DataOut_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_AW_ANONYMOUS_STRUCT_1_LabelOut_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_AW_ANONYMOUS_STRUCT_1_LabelOut_ 0x00
// defines for type union (typedef T_ARINC_WORD_OUT)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_OUT_    0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_OUT_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_OUT_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_OUT_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_WordOut_ T_uint32
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_WordOut_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_WordOut_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_Field_ T_struct
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_Field_ 0x00
#define _CHAN_MEMBER_TYPE_STRUCT_eTPU_A429_TransmitMaster_T_ARINC_WORD_OUT_Field_ AW_ANONYMOUS_STRUCT_1
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_T_P2_ACCESS_bit_time_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_T_P2_ACCESS_bit_time_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_TransmitMaster_T_P2_ACCESS_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_TransmitMaster_T_P2_ACCESS_status_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_A429_TransmitMaster_arinc_MSG_
#define _CPBA_UNION_eTPU_A429_TransmitMaster_arinc_MSG_ 0x00
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitMaster_arinc_MSG_ T_ARINC_WORD_OUT
#define _CPBA_UNION_eTPU_A429_TransmitMaster_p2_ 0x08
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitMaster_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_A429_TransmitMaster_first_data_ 0x14
#define _CPBA_TYPE_UNION_eTPU_A429_TransmitMaster_first_data_ T_ARINC_WORD_OUT

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_arinc_MSG_ T_union
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_bit_mask_ T_sint24
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_p2_  T_union
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_PTR_buffer_current_ T_ptr
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_PTR_buffer_end_ T_ptr
#define _CPBA_TYPE_eTPU_A429_TransmitMaster_first_data_ T_union

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_A429_TransmitMaster_;
#define _FRAME_SIZE_eTPU_A429_TransmitMaster_    0x18

//============================================================================
//==========     eTPU_A429_ReceiveSlave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_A429_ReceiveSlave_;
#define _FUNCTION_NUM_eTPU_A429_ReceiveSlave_    0x01

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_A429_ReceiveSlave_;
#define _ENTRY_TABLE_TYPE_eTPU_A429_ReceiveSlave_ 0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_A429_ReceiveSlave_sticky_status_
#define _CPBA8_eTPU_A429_ReceiveSlave_sticky_status_ 0x04

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_A429_ReceiveSlave_bit_mask_
#define _CPBA24_eTPU_A429_ReceiveSlave_bit_mask_ 0x05
#define _CPBA24_eTPU_A429_ReceiveSlave_PTR_buffer_current_ 0x0D
#define _CPBA24_eTPU_A429_ReceiveSlave_PTR_buffer_end_ 0x11
#define _CPBA24_eTPU_A429_ReceiveSlave_channel_mask_ 0x15
#define _CPBA24_eTPU_A429_ReceiveSlave_PTR_label_table_ 0x19

// tag type info used by channel frame variables

// defines for type struct AW_ANONYMOUS_STRUCT_1
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_AW_ANONYMOUS_STRUCT_1_DataIn_ T_sint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_AW_ANONYMOUS_STRUCT_1_DataIn_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_AW_ANONYMOUS_STRUCT_1_DataIn_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_AW_ANONYMOUS_STRUCT_1_LabelIn_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_AW_ANONYMOUS_STRUCT_1_LabelIn_ 0x00
// defines for type union (typedef T_ARINC_WORD_IN)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_IN_     0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_IN_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_IN_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_WordIn_ T_uint32
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_WordIn_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_WordIn_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_Field_ T_struct
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_Field_ 0x00
#define _CHAN_MEMBER_TYPE_STRUCT_eTPU_A429_ReceiveSlave_T_ARINC_WORD_IN_Field_ AW_ANONYMOUS_STRUCT_1
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_T_P2_ACCESS_bit_time_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_T_P2_ACCESS_bit_time_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveSlave_T_P2_ACCESS_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveSlave_T_P2_ACCESS_status_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_A429_ReceiveSlave_arinc_MSG_
#define _CPBA_UNION_eTPU_A429_ReceiveSlave_arinc_MSG_ 0x00
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveSlave_arinc_MSG_ T_ARINC_WORD_IN
#define _CPBA_UNION_eTPU_A429_ReceiveSlave_p2_   0x08
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveSlave_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_A429_ReceiveSlave_first_data_ 0x1C
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveSlave_first_data_ T_ARINC_WORD_IN

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_arinc_MSG_ T_union
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_bit_mask_ T_sint24
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_p2_    T_union
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_PTR_buffer_current_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_PTR_buffer_end_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_channel_mask_ T_uint24
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_sticky_status_ T_uint8
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_PTR_label_table_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveSlave_first_data_ T_union

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_A429_ReceiveSlave_;
#define _FRAME_SIZE_eTPU_A429_ReceiveSlave_      0x20

//============================================================================
//==========     eTPU_A429_ReceiveMaster

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_eTPU_A429_ReceiveMaster_;
#define _FUNCTION_NUM_eTPU_A429_ReceiveMaster_   0x00

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_eTPU_A429_ReceiveMaster_;
#define _ENTRY_TABLE_TYPE_eTPU_A429_ReceiveMaster_ 0x01

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_eTPU_A429_ReceiveMaster_sticky_status_
#define _CPBA8_eTPU_A429_ReceiveMaster_sticky_status_ 0x04

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_eTPU_A429_ReceiveMaster_bit_mask_
#define _CPBA24_eTPU_A429_ReceiveMaster_bit_mask_ 0x05
#define _CPBA24_eTPU_A429_ReceiveMaster_PTR_buffer_current_ 0x0D
#define _CPBA24_eTPU_A429_ReceiveMaster_PTR_buffer_end_ 0x11
#define _CPBA24_eTPU_A429_ReceiveMaster_channel_mask_ 0x15
#define _CPBA24_eTPU_A429_ReceiveMaster_PTR_label_table_ 0x19

// tag type info used by channel frame variables

// defines for type struct AW_ANONYMOUS_STRUCT_1
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_RAW_SIZE_AW_ANONYMOUS_STRUCT_1_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_
#define _CHAN_TAG_TYPE_ALIGNMENT_AW_ANONYMOUS_STRUCT_1_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_AW_ANONYMOUS_STRUCT_1_DataIn_ T_sint24
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_AW_ANONYMOUS_STRUCT_1_DataIn_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_AW_ANONYMOUS_STRUCT_1_DataIn_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_AW_ANONYMOUS_STRUCT_1_LabelIn_ T_sint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_AW_ANONYMOUS_STRUCT_1_LabelIn_ 0x00
// defines for type union (typedef T_ARINC_WORD_IN)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_SIZE_T_ARINC_WORD_IN_     0x04
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_RAW_SIZE_T_ARINC_WORD_IN_ 0x04
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_IN_
#define _CHAN_TAG_TYPE_ALIGNMENT_T_ARINC_WORD_IN_ 0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_WordIn_ T_uint32
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_WordIn_
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_WordIn_ 0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_Field_ T_struct
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_Field_ 0x00
#define _CHAN_MEMBER_TYPE_STRUCT_eTPU_A429_ReceiveMaster_T_ARINC_WORD_IN_Field_ AW_ANONYMOUS_STRUCT_1
// defines for type union (typedef T_P2_ACCESS)
#define _CHAN_TAG_TYPE_SIZE_T_P2_ACCESS_         0x04
#define _CHAN_TAG_TYPE_RAW_SIZE_T_P2_ACCESS_     0x04
#define _CHAN_TAG_TYPE_ALIGNMENT_T_P2_ACCESS_    0x00
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_T_P2_ACCESS_bit_time_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_T_P2_ACCESS_bit_time_ 0x01
#define _CHAN_MEMBER_TYPE_eTPU_A429_ReceiveMaster_T_P2_ACCESS_status_ T_uint8
#define _CHAN_MEMBER_BYTEOFFSET_eTPU_A429_ReceiveMaster_T_P2_ACCESS_status_ 0x00

// Channel Struct/Union Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA_UNION_eTPU_A429_ReceiveMaster_arinc_MSG_
#define _CPBA_UNION_eTPU_A429_ReceiveMaster_arinc_MSG_ 0x00
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveMaster_arinc_MSG_ T_ARINC_WORD_IN
#define _CPBA_UNION_eTPU_A429_ReceiveMaster_p2_  0x08
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveMaster_p2_ T_P2_ACCESS
#define _CPBA_UNION_eTPU_A429_ReceiveMaster_first_data_ 0x1C
#define _CPBA_TYPE_UNION_eTPU_A429_ReceiveMaster_first_data_ T_ARINC_WORD_IN

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_arinc_MSG_ T_union
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_bit_mask_ T_sint24
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_p2_   T_union
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_PTR_buffer_current_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_PTR_buffer_end_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_channel_mask_ T_uint24
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_sticky_status_ T_uint8
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_PTR_label_table_ T_ptr
#define _CPBA_TYPE_eTPU_A429_ReceiveMaster_first_data_ T_union

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_eTPU_A429_ReceiveMaster_;
#define _FRAME_SIZE_eTPU_A429_ReceiveMaster_     0x20

#endif // __AUTO_eTPU_auto_H__
